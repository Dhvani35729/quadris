#include <iostream>
#include <fstream>
#include <sstream>
#include <utility>
#include <string>
#include <cstring>
#include <vector>

#include "interpreter.h"
#include "constants.h"

// default constructor
Interpreter::Interpreter()
{
    // Initialize map to Command enum
    this->commandNames_ = {
        "left",
        "right",
        "down",
        "clockwise",
        "counterclockwise",
        "drop",
        "levelup",
        "leveldown",
        "norandom",
        "random",
        "sequence",
        "restart",
        "hint",
        "I",
        "J",
        "L",
        "S",
        "Z",
        "O",
        "T",
        "exit",
        "rename",
        "ai",
    };
}

// destructor
Interpreter::~Interpreter() {}

// Get the list of commands generated by the Interpreter
std::vector<std::pair<Command, int>> Interpreter::getCommands()
{
    return this->commands_;
}

// Add a command and its multiplier to the list of commands
void Interpreter::addCommand(Command command, int multiplier)
{
    this->commands_.push_back(std::make_pair(command, multiplier));
}

// Takes in a string and returns the associated command
// Performs auto complete
Command Interpreter::completer(std::string rawCommand)
{
    std::vector<Command> options;

    // Go through each of the command options, and check
    // if any of the commands start with the rawCommand
    for (int i = 0; i < this->commandNames_.size(); i++)
    {
        if (this->commandNames_[i].rfind(rawCommand, 0) == 0)
        {
            // commandNames[i] starts with rawCommand
            options.push_back((Command)(i));
        }
    }

    // If only one command starts with the raw command
    // there is no ambiguity, and we can return the command
    if (options.size() == 1)
    {
        return options.front();
    }
    else
    {
        return BAD_COMMAND;
    }
}

// Renames the command
// Updates the map to Command enum with the new string name
// Returns true if successful in renaming the command
bool Interpreter::renameCommad(std::string from, std::string to)
{
    for (int i = 0; i < this->commandNames_.size(); i++)
    {
        if (std::strcmp(this->commandNames_[i].c_str(), from.c_str()) == 0)
        {
            this->commandNames_[i] = to;
            return true;
        }
    }
    return false;
};

// Process input and generate commands
std::istream &operator>>(std::istream &in, Interpreter &intp)
{

    std::string cmd;
    in >> cmd;

    // Reset the list of commands
    intp.commands_.clear();

    // If user enters end of file, exit the game
    if (in.eof())
    {
        intp.addCommand(Command(EXIT), 1);
    }
    // Otherwise, parse the command
    else
    {
        intp.parseRaw(in, cmd);
    }

    return in;
}

// Parses the raw command from the stream
// Recursive so that we can use the same method
// to parse commands from a file
void Interpreter::parseRaw(std::istream &in, std::string rawCommand)
{
    // Default multiplier is 1
    int multiplier = 1;

    // Check if there is a multiplier prefix
    int cmdStartIndex = 0;
    for (int i = 0; i < rawCommand.length(); i++)
    {
        if (!std::isdigit(rawCommand[i]))
        {
            cmdStartIndex = i;
            break;
        }
    }

    // If there is a multiplier prefix
    if (cmdStartIndex > 0)
    {
        // Get the multiplier
        multiplier = std::stoi(rawCommand.substr(0, cmdStartIndex));
        // Crop out the multiplier prefix (before checking auto completer)
        rawCommand = rawCommand.substr(cmdStartIndex);
    }

    // Get a Command type from the raw string
    Command parsedCommand = this->completer(rawCommand);

    // If the command is rename, rename the command
    if (parsedCommand == RENAME)
    {
        std::string renameFrom;
        in >> renameFrom;
        std::string renameTo;
        in >> renameTo;
        this->renameCommad(renameFrom, renameTo);
    }
    // if the command is a sequence file
    else if (parsedCommand == SEQUENCE_FILE)
    {
        // Get the sequence file name
        std::string sequenceFile;
        in >> sequenceFile;

        // Read in the file, and for each command
        // make the recursive call to parse the command
        std::string newRawCommand;
        std::ifstream infile(sequenceFile);
        while (std::getline(infile, newRawCommand))
        {
            std::istringstream iss(newRawCommand);
            iss >> newRawCommand;
            parseRaw(iss, newRawCommand);
        }
    }
    // otherwise, add the command and its multiplier
    // to the list of commands interpreted
    else
    {
        this->addCommand(parsedCommand, multiplier);
    }
}
